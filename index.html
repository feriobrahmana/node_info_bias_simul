<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Boolean Network • Two Simulators + Attractor Analysis</title>
<style>
  :root { --bg:#0b0f14; --panel:#111826; --muted:#AAB4C1; --on:#33d17a; --off:#0f1624; --pos:#2E75B6; --neg:#C00000; --grid:#1f2a3a; }
	*{box-sizing:border-box;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Inter,Arial}
	body{margin:0;background:var(--bg);color:#e6edf3}
	header{padding:14px 18px;border-bottom:1px solid #1f2a3a;background:#0d1420;display:flex;gap:12px;align-items:center;justify-content:space-between}
	header .title{font-weight:700;letter-spacing:.2px}
	header .subtitle{color:var(--muted);font-size:12px}
	.wrap{display:grid;grid-template-columns:540px 1fr;gap:14px;padding:14px}
	.card{background:var(--panel);border:1px solid #192235;border-radius:14px;box-shadow:0 8px 30px rgba(0,0,0,.25)}
	.pad{padding:14px}
	.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
	.btn{background:#182236;border:1px solid #26334a;padding:8px 12px;border-radius:10px;color:#e6edf3;cursor:pointer}
	.btn:hover{background:#1d2a42}
	.btn.primary{background:#23365a;border-color:#2f4b7d}
	input[type=number],select{background:#0f1624;border:1px solid #26334a;color:#e6edf3;border-radius:10px;padding:6px 8px}
	.toggle{display:inline-flex;align-items:center;gap:6px;margin-right:10px}
	.toggle input{accent-color:#4aa5ff}
	.grid{overflow:auto;border-top:1px solid #1f2a3a}
	.matrix{display:grid;gap:2px;padding:10px}
	.cell{width:30px;height:22px;border-radius:6px;border:1px solid #1f2a3a;background:var(--off);display:flex;align-items:center;justify-content:center;font-size:11px;color:#9fb2c8}
	.cell.on{background:var(--on);color:#0b1b12;border-color:#0f4d2f}
	.labels{display:grid;gap:2px;padding:10px;padding-right:0}
	.label{height:22px;display:flex;align-items:center;justify-content:flex-end;color:#a9b6c7;font-size:12px;padding-right:6px}
	.columns{display:flex;align-items:center;gap:8px;color:#aab4c1;padding:6px 10px 10px 10px}
	svg text{font-size:12px;fill:#d8e0ea}
	.edge-pos{stroke:var(--pos);stroke-width:2.6;fill:none}
	.edge-neg{stroke:var(--neg);stroke-width:2.6;fill:none}
	.node{fill:#101c2a;stroke:#2c3e55;stroke-width:1.5}
	.code{font-family:ui-monospace,monospace;background:#0c121c;border:1px solid #1b2434;padding:12px;border-radius:10px;white-space:pre-wrap;font-size:12px;margin-top:8px}
	table{border-collapse:collapse;width:100%}
	th,td{border:1px solid #26334a;padding:6px 8px;text-align:center;font-size:13px}
	th{background:#0f1626}
</style>
</head>
<body>
  <header>
	<div>
		<div class="title">Boolean Network — Trading Analogy: Benefit (1) vs Non-benefit (0)</div>
		<div class="subtitle">Each node represents a trading hub or supplier. A '1' state means the hub gains benefit (e.g., successful trade or resource flow), and '0' means no benefit. The network simulates how interdependencies affect trade sustainability under latency-like dynamics.</div>
	</div>
	<div style="display:flex;gap:12px;align-items:center"><span style="color:var(--pos)">■</span> activation <span style="color:var(--neg)">■</span> inhibition</div>
	</header>
	<div style="padding:14px;color:#aab4c1;font-size:14px;max-width:1000px;line-height:1.5">
		This model can be interpreted as a <b>trading or sourcing network</b> — each node (A–E) acts as a participant whose success (benefit) depends on upstream suppliers or partners. Positive (activation) links mean mutual trade advantage, while negative (inhibition) links could represent supply conflicts, competition, or bottlenecks. The dynamics simulate how information latency or dependence affects when the system as a whole reaches a stable “economic” attractor.
	</div>
  </header>

  <!-- APP 1 -->
  <div class="wrap" id="app1">
    <section class="card pad">
      <h3 class="app-title">Network 1</h3>
      <div class="row">
        <label>Columns <input class="cols" type="number" min="8" max="200" value="40" /></label>
        <label>Mode
          <select class="mode">
            <option value="sync">Synchronous</option>
            <option value="async">Asynchronous (random order)</option>
          </select>
        </label>
      </div>
      <div class="row">
        <button class="step btn">Step</button>
        <button class="run btn primary">Run</button>
        <button class="reset btn">Reset</button>
        <button class="randinit btn">Randomize init</button>
        <span class="status" style="color:#aab4c1"></span>
      </div>

      <h3 style="margin-top:12px">Initial Conditions</h3>
      <div class="row initRow"></div>
      <div class="row">
        <button class="all0 btn">All 0</button>
        <button class="all1 btn">All 1</button>
        <small style="color:#aab4c1">(Column‑0 cells are also clickable.)</small>
      </div>

      <h3 style="margin-top:12px">Network Structure</h3>
      <svg class="graphSvg" width="540" height="280" viewBox="0 0 540 280"></svg>

      <h3>Update Equations</h3>
      <div class="code logicTxt"></div>
    </section>

    <section class="card">
      <div class="columns"><div>Click a cell in column 0 to toggle initial state.</div></div>
      <div class="grid gridWrap"></div>

      <div class="pad">
        <h3>Attractor Analysis (Bias of A and B)</h3>
        <div class="row">
          <button class="analyze btn">Analyze now</button>
          <label class="toggle"><input type="checkbox" class="autoAnalyze" checked/> auto-run on changes</label>
          <small style="color:#aab4c1">Scenarios: D random (per step), D clamped 1, D clamped 0.</small>
        </div>
        <div class="analysisStatus row" style="color:#aab4c1;margin-top:6px"></div>
        <div class="analysisTableWrap" style="margin-top:10px"></div>
      </div>
    </section>
  </div>

  <!-- APP 2 (under the first) -->
  <div class="wrap two" id="app2">
    <section class="card pad">
      <h3 class="app-title">Network 2 (Extended chain with F and G)</h3>
      <div class="row">
        <label>Columns <input class="cols" type="number" min="8" max="200" value="40" /></label>
        <label>Mode
          <select class="mode">
            <option value="sync">Synchronous</option>
            <option value="async">Asynchronous (random order)</option>
          </select>
        </label>
      </div>
      <div class="row">
        <button class="step btn">Step</button>
        <button class="run btn primary">Run</button>
        <button class="reset btn">Reset</button>
        <button class="randinit btn">Randomize init</button>
        <span class="status" style="color:#aab4c1"></span>
      </div>

      <h3 style="margin-top:12px">Initial Conditions</h3>
      <div class="row initRow"></div>
      <div class="row">
        <button class="all0 btn">All 0</button>
        <button class="all1 btn">All 1</button>
        <small style="color:#aab4c1">(Column‑0 cells are also clickable.)</small>
      </div>

      <h3 style="margin-top:12px">Network Structure</h3>
      <svg class="graphSvg" width="800" height="300" viewBox="0 0 800 300"></svg>

      <h3>Update Equations</h3>
      <div class="code logicTxt"></div>
    </section>

    <section class="card">
      <div class="columns"><div>Click a cell in column 0 to toggle initial state.</div></div>
      <div class="grid gridWrap"></div>

      <div class="pad">
        <h3>Attractor Analysis (Bias of A and B)</h3>
        <div class="row">
          <button class="analyze btn">Analyze now</button>
          <label class="toggle"><input type="checkbox" class="autoAnalyze" checked/> auto-run on changes</label>
          <small style="color:#aab4c1">Scenarios: D random (per step), D clamped 1, D clamped 0.</small>
        </div>
        <div class="analysisStatus row" style="color:#aab4c1;margin-top:6px"></div>
        <div class="analysisTableWrap" style="margin-top:10px"></div>
      </div>
    </section>
  </div>

<script>
(function(){
  // -------- Generic App Factory -------------------------------------------
  function makeApp(root, spec){
    // Elements
    const els = {
      cols: root.querySelector('.cols'), mode: root.querySelector('.mode'),
      step: root.querySelector('.step'), run: root.querySelector('.run'), reset: root.querySelector('.reset'), randinit: root.querySelector('.randinit'), status: root.querySelector('.status'),
      initRow: root.querySelector('.initRow'), all0: root.querySelector('.all0'), all1: root.querySelector('.all1'),
      graphSvg: root.querySelector('.graphSvg'), logicTxt: root.querySelector('.logicTxt'), gridWrap: root.querySelector('.gridWrap'),
      analyze: root.querySelector('.analyze'), autoAnalyze: root.querySelector('.autoAnalyze'), analysisStatus: root.querySelector('.analysisStatus'), analysisTableWrap: root.querySelector('.analysisTableWrap')
    };

    const NODES = spec.nodes.slice();
    let cols = +els.cols.value|0; let hist=[spec.init? {...spec.init}: Object.fromEntries(NODES.map(n=>[n,0]))]; let running=false, timer=null;

    function at(node,t){ if(t<0) t=0; const vec = hist[Math.min(t,hist.length-1)]||hist[0]; return vec[node]; }
    const OR=(...xs)=> xs.some(x=>x===1)?1:0;

    function nextSync(t, clampD){
      const s = {};
      // compute RHS from spec.rules
      for(const r of spec.rules){
        const ts = r.terms.map(term=> (term.v==='randD'? (Math.random()<0.5?1:0) : at(term.v,t)) * (term.s>0?1:1));
        // op OR (default single term)
        const rhs = (r.op==='OR' || ts.length>1) ? OR(...ts) : ts[0];
        if(r.lhs==='D' && (clampD===0||clampD===1)) s.D = clampD; else s[r.lhs]= rhs;
      }
      return s;
    }

    function nextAsync(t, clampD){
      let curr={...hist[t]};
      const order = NODES.slice().sort(()=>Math.random()-0.5);
      for(const node of order){
        // compute current RHS pulling latest curr values
        const rule = spec.rules.find(rr=>rr.lhs===node);
        let rhs;
        if(node==='D' && (clampD===0||clampD===1)) rhs = clampD; else {
          const vals = rule.terms.map(term=> (term.v==='randD'? (Math.random()<0.5?1:0) : curr[term.v]) * (term.s>0?1:1));
          rhs = (rule.op==='OR' || vals.length>1) ? (vals.some(x=>x===1)?1:0) : vals[0];
        }
        curr[node]=rhs;
      }
      return curr;
    }

    function render(){
      cols=Math.max(8,Math.min(200,+els.cols.value|0));
      els.logicTxt.textContent = spec.textRules.join('\n');

      // matrix
      const T=cols, rows=NODES.length; const matrix=document.createElement('div'); matrix.className='matrix'; matrix.style.gridTemplateColumns=`repeat(${T},30px)`; const labels=document.createElement('div'); labels.className='labels'; labels.style.gridTemplateRows=`repeat(${rows},22px)`;
      for(const node of NODES){ const lab=document.createElement('div'); lab.className='label'; lab.textContent=node; labels.appendChild(lab); for(let t=0;t<T;t++){ const cell=document.createElement('div'); cell.className='cell'; const vec=hist[t]; const val=(vec? vec[node]:undefined); if(val===1) cell.classList.add('on'); if(t===0){ cell.style.cursor='pointer'; cell.addEventListener('click',()=>{ hist[0]={...hist[0],[node]: hist[0][node]?0:1}; hist.splice(1); render(); if(els.autoAnalyze.checked) analyze(); }); } matrix.appendChild(cell);} }
      const wrap=document.createElement('div'); wrap.style.display='grid'; wrap.style.gridTemplateColumns='90px 1fr'; wrap.appendChild(labels); wrap.appendChild(matrix); els.gridWrap.innerHTML=''; els.gridWrap.appendChild(wrap);

      drawGraph(); buildInitToggles();
    }

    function buildInitToggles(){ els.initRow.innerHTML=''; for(const n of NODES){ const wrap=document.createElement('label'); wrap.className='toggle'; wrap.innerHTML=`<input type="checkbox" ${hist[0][n]? 'checked':''}/> ${n}`; const cb=wrap.querySelector('input'); cb.addEventListener('change',e=>{ hist[0]={...hist[0],[n]: e.target.checked?1:0}; hist.splice(1); render(); if(els.autoAnalyze.checked) analyze(); }); els.initRow.appendChild(wrap); } }

    function drawGraph(){
      const svg=els.graphSvg; svg.innerHTML='';
      const pos=spec.layout;
      const NODE_R=12, START_SHRINK=10, END_SHRINK=NODE_R+2;
      const defs=document.createElementNS(svg.namespaceURI,'defs');
      const mk=(id,color)=>{ const m=document.createElementNS(svg.namespaceURI,'marker'); m.setAttribute('id',id); m.setAttribute('markerWidth','12'); m.setAttribute('markerHeight','12'); m.setAttribute('refX','11'); m.setAttribute('refY','6'); m.setAttribute('orient','auto'); const p=document.createElementNS(svg.namespaceURI,'path'); p.setAttribute('d','M0,0 L12,6 L0,12 Z'); p.setAttribute('fill',color); m.appendChild(p); defs.appendChild(m); };
      mk('arrow-pos', getCss('--pos')); mk('arrow-neg', getCss('--neg')); svg.appendChild(defs);
      function shrink(x1,y1,x2,y2){ const dx=x2-x1, dy=y2-y1; const L=Math.hypot(dx,dy)||1; const ux=dx/L, uy=dy/L; return [x1+ux*START_SHRINK, y1+uy*START_SHRINK, x2-ux*END_SHRINK, y2-uy*END_SHRINK]; }
      function edge(u,v,sign,curve=0){ let [x1,y1]=pos[u], [x2,y2]=pos[v]; [x1,y1,x2,y2]=shrink(x1,y1,x2,y2); const g=el('g'); let path; if(curve!==0){ const cx=(x1+x2)/2, cy=((y1+y2)/2)+curve; path=el('path'); path.setAttribute('d',`M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`);} else { path=el('line'); path.setAttribute('x1',x1); path.setAttribute('y1',y1); path.setAttribute('x2',x2); path.setAttribute('y2',y2);} path.setAttribute('class',sign>0?'edge-pos':'edge-neg'); path.setAttribute('marker-end',`url(#${sign>0?'arrow-pos':'arrow-neg'})`); g.appendChild(path); svg.appendChild(g); }
      function sign(u,v){ const r=spec.rules.find(rr=>rr.lhs===v); const term=r.terms.find(t=>t.v===u); return term? term.s:+1; }

      // edges from rules (no labels)
      for(const r of spec.rules){ for(const term of r.terms){ const u=term.v, v=r.lhs; if(u==='randD') continue; function curveFor(u,v){
        // Curves for overlapping/ambiguous edges
        if(u==='A'&&v==='B') return -26;      // top arc A→B
        if(u==='B'&&v==='A') return -18;      // top arc B→A
        if(u==='E'&&v==='B') return -10;      // diagonal E→B
        if(u==='C'&&v==='E') return 12;       // chord along bottom (separate from C→D→E)
        return 0;
      }
      const curved = curveFor(u,v);
      edge(u,v, sign(u,v), curved); } }

      // nodes
      for(const n of NODES){ const [x,y]=pos[n]; const g=el('g'); const c=el('circle'); c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',NODE_R); c.setAttribute('class','node'); const t=el('text'); t.setAttribute('x',x); t.setAttribute('y',y+4); t.setAttribute('text-anchor','middle'); t.textContent=n; g.appendChild(c); g.appendChild(t); svg.appendChild(g); }
      function el(name){ return document.createElementNS(svg.namespaceURI,name); }
      function getCss(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
    }

    function step(){ const t=hist.length-1; const nxt=(els.mode.value==='sync')? nextSync(t, null): nextAsync(t, null); hist.push(nxt); render(); }
    function toggleRun(){ running=!running; els.run.textContent=running? 'Pause':'Run'; els.status.textContent=running? 'running…':''; if(running){ timer=setInterval(()=>{ if(hist.length>=cols){toggleRun();return;} step(); },120);} else clearInterval(timer); }

    // Analysis --------------------------------------------------------------
    function analyze(){ els.analysisStatus.textContent='Analyzing…'; setTimeout(()=>{ const results=[]; const scenarios=[{name:'D random (p=0.5 each step)',clamp:'rand'},{name:'D clamped ON',clamp:1},{name:'D clamped OFF',clamp:0}]; for(const s of scenarios){ const r=(s.clamp==='rand')? analyzeRandomD(): analyzeDeterministicD(s.clamp); results.push({scenario:s.name, A_bias:r.A_bias.toFixed(3), B_bias:r.B_bias.toFixed(3)});} renderAnalysisTable(results); els.analysisStatus.textContent=''; },10); }

    function analyzeDeterministicD(clampD){ let sumA=0,sumB=0,count=0; for(let mask=0; mask<(1<<NODES.length); mask++){ const s0={}; for(let i=0;i<NODES.length;i++){ s0[NODES[i]]=(mask>>i)&1; } const avg=settleAndAverageCycle(s0,clampD); sumA+=avg.A; sumB+=avg.B; count++; } return {A_bias:sumA/count,B_bias:sumB/count}; }
    function settleAndAverageCycle(s0,clampD){ const seen=new Map(); let s={...s0}; const seq=[]; let t=0; while(true){ const key=NODES.map(k=>s[k]).join(''); if(seen.has(key)){ const start=seen.get(key); const cyc=seq.slice(start); const avgA=cyc.reduce((a,v)=>a+v.A,0)/cyc.length; const avgB=cyc.reduce((a,v)=>a+v.B,0)/cyc.length; return {A:avgA,B:avgB}; } seen.set(key,t); seq.push(s); s=nextFromStateDeterministic(s,clampD); t++; if(t>300) break; } return {A:s.A,B:s.B}; }
    function nextFromStateDeterministic(state,clampD){ const nxt={}; for(const r of spec.rules){ if(r.lhs==='D' && (clampD===0||clampD===1)){ nxt.D=clampD; continue; } const vals=r.terms.map(term=> state[term.v]); const rhs=(r.op==='OR'||vals.length>1)? (vals.some(x=>x===1)?1:0) : vals[0]; nxt[r.lhs]=rhs; } return nxt; }
    function analyzeRandomD(){ const K=40,T=80,L=20; let sumA=0,sumB=0,trials=0; for(let mask=0; mask<(1<<NODES.length); mask++){ const s0={}; for(let i=0;i<NODES.length;i++){ s0[NODES[i]]=(mask>>i)&1; } for(let k=0;k<K;k++){ let s={...s0}; for(let t=0;t<T;t++){ s=nextRandD(s);} let a=0,b=0; for(let t=0;t<L;t++){ s=nextRandD(s); a+=s.A; b+=s.B; } sumA+=a/L; sumB+=b/L; trials++; } } return {A_bias:sumA/trials,B_bias:sumB/trials}; }
    function nextRandD(state){ const nxt={}; for(const r of spec.rules){ const vals=r.terms.map(term=> term.v==='randD'? (Math.random()<0.5?1:0) : state[term.v]); const rhs=(r.op==='OR'||vals.length>1)? (vals.some(x=>x===1)?1:0) : vals[0]; nxt[r.lhs]= rhs; } return nxt; }
    function renderAnalysisTable(rows){ const tbl=document.createElement('table'); const thead=document.createElement('thead'); thead.innerHTML='<tr><th>Scenario</th><th>Bias A=P(A=1)</th><th>Bias B=P(B=1)</th></tr>'; const tbody=document.createElement('tbody'); for(const r of rows){ const tr=document.createElement('tr'); tr.innerHTML=`<td>${r.scenario}</td><td>${r.A_bias}</td><td>${r.B_bias}</td>`; tbody.appendChild(tr);} tbl.appendChild(thead); tbl.appendChild(tbody); els.analysisTableWrap.innerHTML=''; els.analysisTableWrap.appendChild(tbl); }

    // Events
    els.cols.addEventListener('change',()=>{ render(); if(els.autoAnalyze.checked) analyze(); });
    els.mode.addEventListener('change',()=>{ render(); });
    els.step.addEventListener('click',()=>{ if(hist.length<cols) step(); });
    els.run.addEventListener('click',()=>{ toggleRun(); });
    els.reset.addEventListener('click',()=>{ if(running) toggleRun(); hist=[spec.init? {...spec.init}: Object.fromEntries(NODES.map(n=>[n,0]))]; render(); if(els.autoAnalyze.checked) analyze(); });
    els.randinit.addEventListener('click',()=>{ if(running) toggleRun(); const init={}; NODES.forEach(n=> init[n]=(Math.random()<0.5)?0:1); hist=[init]; render(); if(els.autoAnalyze.checked) analyze(); });
    els.all0.addEventListener('click',()=>{ if(running) toggleRun(); const init={}; NODES.forEach(n=> init[n]=0); hist=[init]; render(); if(els.autoAnalyze.checked) analyze(); });
    els.all1.addEventListener('click',()=>{ if(running) toggleRun(); const init={}; NODES.forEach(n=> init[n]=1); hist=[init]; render(); if(els.autoAnalyze.checked) analyze(); });
    els.analyze.addEventListener('click', analyze);

    // Boot
    render(); analyze();
  }

  // -------- Define both network specs -------------------------------------
  const spec1 = {
    nodes:['A','B','C','D','E'],
    rules:[
      {lhs:'A', terms:[{v:'B', s:+1}]},
      {lhs:'B', terms:[{v:'A', s:+1},{v:'E', s:+1}], op:'OR'},
      {lhs:'C', terms:[{v:'A', s:+1}]},
      {lhs:'D', terms:[{v:'C', s:+1}]},
      {lhs:'E', terms:[{v:'D', s:+1},{v:'C', s:+1}], op:'OR'}
    ],
    textRules:[
      'A(t+1) = B(t)',
      'B(t+1) = A(t) ∨ E(t)',
      'C(t+1) = A(t)',
      'D(t+1) = C(t)',
      'E(t+1) = D(t) ∨ C(t)'
    ],
    layout:{A:[60,80], B:[420,80], C:[170,140], D:[270,200], E:[360,140]},
    init:{A:1,B:0,C:0,D:0,E:0}
  };

  const spec2 = {
    nodes:['A','B','C','F','D','G','E'],
    rules:[
      {lhs:'A', terms:[{v:'B', s:+1}]}, // A = B
      {lhs:'B', terms:[{v:'A', s:+1},{v:'E', s:+1}], op:'OR'}, // B = A ∨ E
      {lhs:'C', terms:[{v:'A', s:+1}]}, // C = A
      {lhs:'F', terms:[{v:'C', s:+1}]}, // F = C
      {lhs:'D', terms:[{v:'F', s:+1}]}, // D = F
      {lhs:'G', terms:[{v:'D', s:+1},{v:'F', s:+1}], op:'OR'}, // G = D ∨ F
      {lhs:'E', terms:[{v:'G', s:+1},{v:'C', s:+1}], op:'OR'} // E = F ∨ C
    ],
    textRules:[
      'A(t+1) = B(t)',
      'B(t+1) = A(t) ∨ E(t)',
      'C(t+1) = A(t)',
      'F(t+1) = C(t)',
      'D(t+1) = F(t)',
      'G(t+1) = D(t) ∨ F(t)',
      'E(t+1) = F(t) ∨ C(t)'
    ],
    layout: {A:[60,80], B:[420,80], C:[170,140], F: [220,200], D: [270,240], G: [310,200], E:[360,140]},
    init:{A:1,B:0,C:0,F:0,D:0,G:0,E:0}
  };

  // Mount apps
  makeApp(document.getElementById('app1'), spec1);
  makeApp(document.getElementById('app2'), spec2);
})();
</script>
</body>
</html>
